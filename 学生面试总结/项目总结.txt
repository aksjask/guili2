1.广告模块
	广告模块就是我们商城项目的首页,他是作为系统的入口,考虑到它的访问量比较大,而且数据都是由后台内容管理系统进行动态维护,如果每次访问都直接去查询数据库,数据库的压力就会特别的大,如果遇到访问高峰期,巨大的流量很可能直接将数据库打死,然后整个系统就瘫痪了.而且广告内容的时效性要求也不是很高,所以我们在广告模块里用了redis缓存技术.第一次访问请求,先去redis中查询数据,如果数据不存在,就去数据库中去查询,查询到结果存入到缓存中,存储到缓存中的数据类型是hash类型,大key是固定的,而小key则是不同广告分类的id(比如说首页轮播,猜你喜欢等等),存进去则是广告对象集合并返回给用户,下一次的请求直接去数据库中查询即可,减轻数据库的访问压力,而且从缓存中查询的速度要比从数据库中查询快,提高了用户的体验.当运营商后台修改首页的内容之后,它会先执行修改操作,然后将修改的请求发送到activeMQ,以jms queue的形式发送,广告模块收到消息后,就先去删除redis中的广告缓存,然后再去执行数据库的修改操作,这样就能初步防止缓存与数据库中数据不一致的情况
	
2.商家后台模块
	商家后台模块我主要的负责的是品牌管理模块和商品规格管理部分,商品分类管理
	首先,品牌管理主要是品牌种类的增删改查,主要为后面商品录入时选择对应的品牌做服务,商家可以在后台录入自家的经营的品牌,然后再数据库中生成品牌相应的数据,然后商家在后台就可以查看到自家的品牌,在录入商品时可以选择商品的品牌;
	在商品规格管理模块的逻辑和商品品牌管理类似,唯一不同的是商品规格管理这一块数据库里有两张表,分别为规格表和规格选项表,规格选项表是对规格表的补充,规格表和规格选项表是一对多的关系
	我们先设置一个规格传输类,属性分别由规格的属性,以及还有一个规格选项的集合,商家在新增规格的时候,可以点击按钮增加该规格的规格选项,所以前端传来的数据是一个规格对象和规格选项的集合,然后数据传到后台经过解析,得到一个规格传输类对象,进行数据库操作时,先创建一个规格对象对其进行赋值,然后存入数据库,然后遍历规格选项的集合,然后往数据库里面进行插入操作;查询就是根据该规格id去规格表查询对应的规格对象,然后再去规格选项表中查询规格id所对应的规格选项对象,返回一个规格选项的集合,然后将规格对象和规格选项集合设置进规格传输类对象去,返回到页面前台;删除值得注意的是,就是删除规格对象的同时,要将对应的规格选项也要一同删除
	
3.商品详情页
	商品详情页我们是储存在Nginx服务器上的,所有的商品详情页就公用一套模板.运营商通过了商品的审核或者发生改变,就会发送消息到activeMQ,发送的消息内容,就是商品的id,详情页生成模块会有消息监听器,当监听到消息,获取到消息的内容,也就是商品id,然后通过商品id,去数据库里面查询该商品所对应的属性,比如商品信息,商品详情信息,所属的分类信息,最主要的该商品的sku信息,把查询到信息都存放到modelMap里,然后发送到模板里,模板根据对应的信息进行数据的填充,生成商品详情页,商品详情页就是商品的id.html,这样就能保证我们修改商品后新的详情页会覆盖之前的详情页;值得注意的是该商品的每个sku信息,先存在模板的java script定义的sku集合中.这样在客户选择规格选项后就不用再去后台数据库查询数据,直接可以在页面上获得数据.
	
4.购物车的实现
	我觉得国内购物网站的购物车最人性化的就是京东了,它在用户未登录的情况下就可以使用,往里面添加商品,然后等到你点击结算的时候,才提醒你去登录,而且登录后购物车里的商品依然存在.我们购物车的实现也是类似于京东的逻辑,在用户为登录的时候,就将用户的购物车存在cookie中,设置cookie的最大存活时间为7天,用户可以往cookie里面添加商品,等到用户点击结算的后,就会跳转登录页面,用户登录后.就会把cookie中的购物车信息取出来与redis中的购物车的购物车信息进行合并,如果是同一个商家的同一个商品就进行商品数量的增加;
	
	首先,我们项目里的购物车是每个商家对应一个购物车,购物车对象里面由商家id,商家名称,已经商家的商品的list集合
	用户在商品页面点击添加到购物车时,后台先去cookie中查找购物车集合的json字符串,,经过解析成购物车list集合.然后判断用户有没有登录,如果用户已经登录,就从redis中提取用户的购物车,购物车存储在redis中是hash类型,大key是固定的,小key则是当前用户的id,存进去的是个购物车list集合.根据用户id得到购物车后,再去根据添加商品的skuID去查询商品明细SKU对象,查询到sku对象就能商家id,然后根据商家id在购物车列表中查询购物车对象,如果不存在该商家的购物车对象,就会新创建一个购物车对象,把商品添加到这个购物车对象中,然后再购物车list集合中添加该购物车对象;如果购物车list集合中已经存在该商家的购物车对象,就直接将商品添加到对应的购物车对象中,如果该商品已经存在于该购物车对象,就进行数量的增加,同时更新金额.相应的如果是商品移除,如果该商品的数量等于0,就要在购物车中移除该商品明细对象,如果购物车的商品列表等于0,就要移除该商家的购物车
	
5.秒杀模块
	运营商后台,先设置秒杀商品信息,包括商品的id,秒杀的库存等,将这些放到redis中,因为redis性能高,读写快,能够应对高并发的访问量
	首先用户先去查询当前可以秒杀的商品信息,如果商品库存大于0,可以点击秒杀按钮,参与秒杀,去redis中查询商品商品的库存,如果库存小于1,提示用户秒杀已结束,如果库存大于1,则可以继续进行秒杀,就会进行下单,减库存,生成订单,此时订单的状态显示未付款;如果用户超过100秒未付款,则秒杀失败返还库存,并且订单的状态修改为取消;如果用户在规定时间内付款成功,则修改订单状态为已付款
	由于这里考虑到高并发访问请求,可能导致超卖的现象,所以这里采用了redis分布式锁,来保障线程安全问题,redis分布式锁主要应用了redis的setnx和getset两个命令,先通过setnx不成立的情况下加锁,如果客户端获得锁,则setnx返回1,如果setnx返回0,则表示该键已经被其它客户端给锁定,但是这种情况下容易发生死锁,如果客户端获得锁后,执行发生了异常,导致该锁没有被释放,外面的客户端一致无法获得锁;所以通过getset命令来解决死锁情况;所有的请求都带着相同的key也就是商品的id来获取锁,他们的value则是当前时间+超时时间的字符串,如果线程获得锁后执行成功没有发生异常,就会解锁,删除这个key,以便接下来的线程能够获得锁;如果线程执行的过程中发生了异常,则就先取出当前redis中key所对应的value和当前时间比较,判断有没有过期,如果以过期,就执行getset方法,再获得上一个锁的value,判断两次value是否相等,如果相等则获得锁对象, 如果不等则继续阻塞中.经过aparch ab压力测试,在每秒500并发请求下,没有出现线程安全
	
RestFUL编程风格
	一种软件架构风格,用来描述网络中客户端和服务的交互,来达到使用url来定位资源,用HTTP动词描述风格的操作的效果,为各种类型的客户端提供一套统一的服务接口
	
	POST:新建或更新资源
	GET:获取资源
	PUT:更新资源
	DELETE:删除资源
	
开发中遇到的bug,事怎么解决的
	我之前做的一个商城项目,静态页面生成模块需要依赖运营商后台和商品后台传输过来的数据,才能进行生成商品详情页,模块的基本功能做好后,我发现无论怎么修改都无法生成商品详情页,一直报空指针异常,一开始我以为是我负责的模块出了问题,那天我花了一上午的时间都在检查自己的代码,查bug,最后发现不是我的代码问题,然后我就去activeMQ控制中心去查看,发现消息中间件中没有消息,然后就去百度了一下消息中间件丢失的问题,了解到消息丢失的相关问题,然后配置了消息重发机制和ack确认机制,这才保证了,消息的不丢失,然后我做的模块就没有异常,详情页也能正常生成