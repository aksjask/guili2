JVM内存
	主要分为线程独占区和线程共享区,线程独占区主要有虚拟机栈,本地方法栈和程序计数器,线程共享区主要有方法区和堆

堆内存
	分为新生代,老年代,新生代里面又划分了伊甸园和两个存活区s0,s1,创建对象优先会被分配到伊甸园,这是垃圾回收机制最先光顾的地方,主要采用标记清除的算法,在经历过第一次Minor GC后,对象仍然存活,就会被移到存活区,存活区的对象每熬过一次minor GC年龄就会增加,增加到一定程度,就会被移动到老年代,而大对象则会直接分配到老年代.
	
	修改堆内存大小:
		-xmx -xms
		
	打印GC日志:
		-verbose:gc
		-xx:PrintGCDetails
	
	
Minor GC, Major GC, Full GC
	Minor GC:清理新生代的内存,伊甸园是标记清除算法,存活区是复制算法
	Major GC:清理老年代(触发一般伴随者Minor GC),标记整理算法
	Full GC:清理整个堆空间
	
两个存活区
	存活区的意义:减少被送到老年代的对象,进而减少Full GC的发生,存活区作为预筛选的保证,只要保证经历过一定次数的Minor GC还能在新生代存货的对象,才会被送到老年代
	
	两个:解决内存碎片化的问题
	
判断对象为垃圾对象
	1.引用计数法
	2.可达性分析法:就是当GC roots和对象之间没有可达路径,就认为这个对象是不可达的,经历过两次不可达标记,对象就会被认定为可回收对象
		GC roots:虚拟机栈,对象
	
程序计数器
	是线程独占区的一块较小的空间,可以看成当前线程所执行的字节码的行号指示器;java方法,程序计数器记录的是字节码指令的地址值,native方法,则是undefined
	
JIT技术
	即时编译技术,在jdk1.2时被引进,当jvm发现某个方法或代码运行特别频繁时,就会认为这是热点代码,JIT将这部分代码翻译成本地机器码,并进行优化缓存起来,以备下次使用
	
逃逸分析
	目前Java虚拟机中比较前沿的优化技术,可以有效减少Java程序中同步负载和内存堆分配压力;通过逃逸分析,虚拟机编译器能够分析出一个新的对象的引用的适用范围,从而决定是否将这个对象分配到堆上
	
	逃逸分析的基本行为就是分析对象的动态作用域:当一个对象在方法中被定义后,它很可能被外部方法所引用,被称为方法逃逸;如果赋值给类变量或者可以在其他线程中访问的实例变量,则被成为线程逃逸
	
	1.同步省略:如果一个对象只能被一个线程所访问,那么这个对象的操作的操作可以不考虑同步,就是锁消除
	
	2.将堆分配转化为栈分配:如果一个对象在一个方法中被创建,外部方法无法引用,此时将该对象分配在栈内存中,就不会有逃逸现象
	
	3.分离对象或标量替换:在jit阶段,如果经过逃逸分析,发现一个对象不会被外界访问,经过jit优化,就会把这个对象拆解成若干个成员变量来替代
	
内存溢出
	内存移除分为堆内存溢出,栈内存移除,本地方法区溢出,线程区溢出,还有堆外内存溢出
	1.堆内存溢出就是强引用太多,gc回收不了,一下子创建30w个对象
	2.栈内存溢出,方法调用层级太深就会导致溢出,比如无限递归调用
	3.本地方法区溢出就是native方法加载太多
	4.线程区溢出,实例化的thread太多,然后任务周期太长导致的
	5.堆外内存溢出,就是通过nio创建,bytebuff会申请堆外内存,这个内存gc释放不了,需要手动释放
	
bio:同步阻塞的,一个socket连接一个处理线程
nio:同步非阻塞的,只有进行io操作的才能获得服务端的处理线程进行io
aio:异步阻塞的,需要进行io操作时,先向分离器发送io请求,分离器通知操作系统进行io操作,操作系统完成后通知分离器,分离器通知程序io操作完成,程序进行数据的读写


类加载的过程
	加载 -> 验证 -> 准备 -> 解析 -> 初始化
	
	加载:1.获取类的二进制字节流
		 2.将字节流代表的静态存储结构转化为方法区运行时数据结构
		 3.在队中生成class字节码对象
		 
	验证:连接过程的第一步,确保class文件的字节流中的信息符合当前虚拟机的要求,不会危害虚拟机的安全
	
	准备:为类的静态变量分配内存并将其初始化为默认值
	
	解析:虚拟机将常量池内符号引用替换成直接引用的过程
	
	初始化:执行类构造器的clinit的过程
	
	
对象初始化的过程
	父类的类构造器 -> 子类的类构造器 -> 父类的类成员变量赋值 -> 父类构造函数 -> 子类的类成员变量赋值 -> 子类构造函数
	
JVM伪共享
	内存缓存系统中基本单元是高速缓存行,cpu会把数据从内存加载到高速缓存行中,这样就能获得更好的性能,高速缓存默认64byte是一个区域,一个区域在一个时间带你只允许一个核心操作,而一个区域可以存放多个字段,如果连个不同线程操作的字段放在同一高速缓存区,那么只能进行单线程操作,严重影响性能
	解决方案:Disruptor字节填充框架,将单个线程操作的字段的剩余空间填满,保证多个字段不被访日同一个高速缓冲区